系统约束：
1. 认为所给的候选议题总时长不超过两天会议议程时长，即 (180 + 240) * 2 分钟
2. 认为上午的会议必须排满，即180分钟，下午的会议时间范围在180到240分钟之间。
3. 只求出满足会议议程时间的可选议题组合，如：满足上午会议时间的议题组合有；S1，S2，S3；实际排列有6种：<S1, S2, S3>  <S1, S3, S2> ……


解决方案；
首先将问题抽象成一个排列组合问题，即：从给定一个大小为n的集合，从中任意取m个元素，要求m个元素的求和满足一定条件

其次，在将这个一定条件抽象成一个可自定义的接口

将组合问题，一般普遍解法，通过递归方式选择可满足条件的元素

结合具体业务，会议议程分两天，每天分上下午两场，同时上午按议题时间排满，下午有1个小时的弹性时间。

这里就需要对条件实现类进一步分析：
1. 条件实现类，对已经选择入队的元素时间求和
2. 求和过程中要匹配上午和下午两场
3. 上午的条件要求严格等于，下午的时间和要落在4：00到5：00的时间窗内
4. 区分满足条件、小于条件、大于条件三种判定结果

递归过程中，根据这三种结果进行逻辑判定

主干流程大概分为三步骤，
第一步：使用组合算法按条件选择满足的议题列表
第二步：从剩下的议题中继续使用组合算法按条件选择满足的议题列表
第三部：按照系统约束1和2，将存在遗留议题的解决方案筛除，剩余的即为可选方案


工程简介：
src为业务源码
test为单元测试代码，实现太仓促，单元测试写的较少

SystemMain为工程运行总入口，main方法有且只有一个参数，即议题列表文件
格式如题目所列

core包路径，将上述解决方案中抽象的排列组合问题进行解决实现

其中Processor为主要实现类，使用递归方式遍历查找符合条件的元素，加入集合
Condition类为抽象的一个满足条件接口，在具体问题解决时，可以对该接口自定义

Solution类，存储一个满足条件的元素组合

Element类，定义了基本数据类型，包含下标和取值

Utils类，主要是一些封装的静态方法

conference包：主要实现了业务逻辑，解决会议议题选择问题
StageSumCondition 实现了Condition类，与实际业务相结合，根据业务具体情况实现满足问题解决的条件方法isSatisfy

Conference类，数据类，用来存放可供选择的议题组合方案
Session类，Track类，根据业务抽象的数据类，与具体业务场景匹配


// 单元测试用例
1. 存在满足第一阶段求和，小于第二阶段范围最小值
预期： 无解决方案
30, 30, 45, 45, 30, 60

2. 存在满足第一阶段求和，大于第二阶段范围最大值
预期： 无解决方案
60,60,60, 241


3. 存在满足第一阶段求和，等于第二阶段范围最小值
预期： 有
30, 30, 45, 45, 30, 60, 60, 60

3. 存在满足第一阶段求和，等于第二阶段范围最大值
预期： 有
30, 30, 45, 45, 30, 60, 60, 60, 60

3. 顺序求和满足第一阶段，总求和在第二阶段范围内
预期： 有
30, 30, 45, 45, 30, 60, 60, 60, 15
